---
title: "Normalizing and plotting vowels with phonR 1.0-0"
runningtitle: "phonR 1.0-0 vignette"
author: "Daniel R. McCloy"
date: "`r Sys.Date()`"
output:
  rmarkdown::html_vignette:
    fig_caption: true
    fig_width: 7.5
    fig_height: 7.5
vignette: >
  %\VignetteIndexEntry{Normalizing and plotting vowels with phonR 1.0-0}
  %\VignetteEngine{knitr::rmarkdown}
  %\usepackage[utf8]{inputenc}
---
```{r, echo=FALSE}
knitr::opts_chunk$set(collapse=TRUE, comment="#>", warning=FALSE, message=FALSE)
```

# Introduction
The `phonR` package provides functions for vowel formant frequency and $f_0$ normalization, as well as a vowel plotting function `plotVowels` with many advanced features. There are also a few functions for calculating the area of the vowel space (either as a convex polygonal hull or a polygon connecting the mean values of the vowels), and for calculating the repulsive force of the vowel system. Finally, there are several helper functions that serve to simplify the `phonR` codebase; those are described in the documentation distributed with the package, but are not discussed further here. `phonR` also includes sample data in the form of F1 and F2 measurements for eight speakers of Standard Indonesian.

## Installation
The phonR package can be downloaded from the [Comprehensive R Archive Network](http://cran.r-project.org/package=phonR) or installed through `R` via `install.packages("phonR")`. The source code is hosted on [GitHub](https://github.com/drammock/phonR), and is licensed under [GPL-3](http://www.gnu.org/licenses/gpl.html). `phonR` has three dependencies (all relating to the vowel space heatmaps): `deldir` (for Delaunay triangulations), `plotrix` (for creating color scales), and `splancs` (for point-in-polygon functions). Plotting vowels with non-ASCII characters (i.e., most vowel symbols in the IPA) also requires that the user’s computer have a typeface installed that contains glyphs at the necessary codepoints, and that the user specify that typeface when calling the `plotVowels` function.

## A note about the examples
All the examples make use of the `R` `with()` syntax. If you’ve never used `with`, the short explanation is it allows you to access the columns of a dataframe without the `$` operator. So instead of `plotVowels(indo$f1, indo$f2)` you can say `with(indo, plotVowels(f1, f2))`. It functions similar to providing a `data` argument in functions like `lm` or in older versions of `plotVowels`.

## Changes from previous versions
The `1.0-0` release of `phonR` is a major update that includes changes to the API and dramatically expanded functionality. Unfortunately this means a couple of features were sacrificed. As implied above, there is no longer a `data` argument to the `plotVowels` function, but comparable simplicity can be had by using the `with` syntax built into `R`. Older versions of `plotVowels` also had built-in support for multiple figures with identical axis ranges (useful when comparing vowels from different speakers or groups, in cases where plotting all speakers/groups on the same graph is untenable). This functionality is also removed, although comparable results are now available using base `R` multi-plot layout commands such as `par(mfrow=c(2, 2))`; an example of this will be given in a later section. Finally, the ability of the `plotVowels` function to do on-the-fly normalization has been removed, and with it the ability to draw axes with tick marks corresponding to evenly-spaced Hertz values (rendered as unevenly spaced in the units of the plot). The rationale for removing these capabilities is that it is not burdensome to have to normalize formant frequencies prior to plotting, and the “Bark-transformed Hertz” style of axis annotation was handy as a teaching tool but not obviously useful when generating plots for publication.

# The `plotVowels` function
The `plotVowels` function has been developed to be maximally compatible with the base `R` function `plot`, so that many familiar function arguments and graphical parameters can be passed to `plotVowels` and work as expected. Arguments like `family` for specifying font family, `xlab`, `ylab`, `main` and `sub` for axis annotation and titles, or `xlim` and `ylim` for specifying axis bounds are all respected. Other arguments applicable to direct-to-file plotting are also respected (e.g., `filename`, `width`, `height`, `res`, `units`, etc). Finally, just as with the base `plot` function, arguments specific to the individual components of the plot such as `cex.main`, `col.axis`, or `font.main` are available to specify the size, color, and font style of titles, axes, and axis labels.

## Basic plotting
Using the included `indo` vowel data, the default behavior of `plotVowels` is not much different from a standard `plot` command, with the exception that the axis directions are reversed (as is standard practice in linguistics).

```{r, fig.cap="A near-minimal `plotVowels` call"}
source("/home/dan/Documents/academics/tools/phonR/R/phonR.R")
load("/home/dan/Documents/academics/tools/phonR/data/indoVowels.rda")
#library(phonR)
#data(indoVowels)  # provides dataframe "indo"
with(indo, plotVowels(f1, f2))
```

### The arguments `vowel`, `group`, `col.by` and `style.by`
Of course, there is little point in plotting all the vowels with the same symbol, and without further information, `plotVowels` doesn't know which F1 and F2 values belong to which vowel and which talker or group. It also doesn't know how you want them plotted, which is why the next plot looks just like the previous one: even though we have *semantically* distinguished the data points by telling `plotVowels` which formant values belong to which vowel / talker, we haven't specified any way of *visually* distinguishing the points on the plot.

```{r, fig.cap="Specifying `vowel` and `group` doesn't automatically change the appearance!"}
with(indo, plotVowels(f1, f2, vowel=vowel, group=gender))
```

The next plot solves this problem by specifying various ways to assign colors and styles to the plot. On the top left, both color and symbol redundantly encode vowel identity. On the top right, color encodes the gender of the talker, and symbol type again encodes vowel identity. On the bottom left, color varies by talker and symbol varies by gender; on the bottom right, color varies by talker, and symbol again varies by gender.

```{r, fig.cap="Four different combinations of `col.by` and `style.by`"}
par(mfrow=c(2, 2))
with(indo, plotVowels(f1, f2, style.by=vowel, col.by=vowel))
with(indo, plotVowels(f1, f2, style.by=vowel, col.by=gender))
with(indo, plotVowels(f1, f2, style.by=subj, col.by=vowel))
with(indo, plotVowels(f1, f2, style.by=gender, col.by=subj))
```

Notice that in none of these plots are we making use of the `vowel` and `group` arguments; as we will see later, these are used for the calculation of vowel means and the drawing of ellipses and polygons based on those calculations, but are functionally independent from the way `plotVowels` controls color and style (viz. `col.by` and `style.by`).

### The `pretty` argument
By now you will have noticed that the default colors and symbols are ugly, and the axes are on the wrong sides of the plot (from a phonetician’s perspective, anyway). `plotVowels` has a wonderful argument called `pretty` that sets a whole bunch of default color and style options all at once, as a shortcut to getting plots that are easy on the eyes. Take a look at the same four plots you just saw, but `pretty`:

```{r, fig.cap="Default appearance with pretty=TRUE"}
par(mfrow=c(2, 2))
with(indo, plotVowels(f1, f2, style.by=vowel, col.by=vowel, pretty=TRUE))
with(indo, plotVowels(f1, f2, style.by=vowel, col.by=gender, pretty=TRUE))
with(indo, plotVowels(f1, f2, style.by=subj, col.by=vowel, pretty=TRUE))
with(indo, plotVowels(f1, f2, style.by=gender, col.by=subj, pretty=TRUE))
```

Don’t worry if you don’t love the colors, or want different symbols or a different size: anything that `pretty` changes can be overridden by explicitly including extra graphical arguments in the `plotVowels` function call, while leaving the remaining `pretty` options in place. The only thing you can’t undo is the axis placement on the top and right instead of bottom and left — that one is hard-wired. We’ll be leaving `pretty=TRUE` from now on, so you’ll see how it affects other aspects of the plots as we proceed.

### Tokens, means, and groups
As we have seen, the default for `plotVowels` is to plot each individual vowel token, potentially colored and styled in different ways. But sometimes a summary view is helpful to look at group differences. This is easily achieved by turning off the `plot.tokens` argument (which defaults to `TRUE`) and turning on the `plot.means` argument (which defaults to `FALSE`). Now that we’re calculating means for each vowel, the `vowel` and `group` arguments become important. These next two plots show the mean F1 and F2 values for each vowel, but with different grouping factors: on the left, the mean for each vowel is calculated within-speaker; on the right, the means are calculated within gender groups.

```{r, fig.height=3.75, fig.cap="Means plotted with different grouping factors"}
par(mfrow=c(1, 2))
with(indo, plotVowels(f1, f2, vowel, group=subj, plot.tokens=FALSE, plot.means=TRUE,
                      col.by=gender, style.by=vowel, pretty=TRUE))
with(indo, plotVowels(f1, f2, vowel, group=gender, plot.tokens=FALSE, plot.means=TRUE,
                      col.by=gender, style.by=vowel, pretty=TRUE))
```

## Advanced plotting
There are several advanced capabilities built into `plotVowels` that can help improve the clarity of your plots and increase their information content. The thoughtful application of the `col.by` and `style.by` arguments in combination with these advanced capabilities can help make even the most complex vowel plots pleasant to look at and easy to understand.

### Plotting with IPA glyphs
`plotVowels` allows you to replace the plotting symbols with arbitrary text, including non-ASCII characters such as IPA glyphs. This can be done separately for the vowel tokens and vowel means using the `pch.tokens` and `pch.means` arguments; while we’re at it, we can change the size separately too using `cex.tokens` and `cex.means`. The vowels of Standard Indonesian in the example data are all transcribed with ASCII characters, so to demonstrate the IPA symbols we’ll add some unnecessary extra symbols and diacritics to plot the means. While we’re at it, we’ll make the tokens smaller and semi-transparent and specify the font family (you can use any typeface that has the glyphs you need and is installed on your system).

```{r, fig.cap="Plot showing semi-transparent tokens and plotting with IPA glyphs"}
remapping <- c(i="ɪʏ̯", e="ɛœ̰ɚ", a="ɒɐ˞", o="ɤɞ̆", u="ɯʊ̥")
with(indo, plotVowels(f1, f2, vowel, plot.tokens=TRUE, pch.tokens=vowel,
                      cex.tokens=0.8, alpha.tokens=0.4, plot.means=TRUE,
                      pch.means=remapping[as.character(vowel)], cex.means=4,
                      col.by=vowel, family="Charis SIL", pretty=TRUE))
```

Notice that the glyphs used to plot the tokens and means need not be the same, and that labels are not restricted to a single glyph (making it easy to symbolize diphthongs, consonantal context, or even use entire words as labels). An important note here is that using non-ASCII symbols in `R` can be somewhat challenging when using `R` in Microsoft Windows, particularly when using Microsoft Excel to organize and store the data. See the Appendix for advice on how to minimize problems when dealing with non-ASCII glyphs on computers running Windows.

### Ellipses, polygons, and hulls
Although seeing the cloud of individual tokens for each vowel is sometimes informative, the plot may become hard to read if there is too much overlap (e.g., due to plotting several different talkers on the same graph). The ability to specify `alpha.tokens` mitigates this to some extent, but in some cases even this is not enough and the plot becomes unreadable. In such cases, ellipses summarizing the range of variation of each vowel can provide a convenient visual summary of the underlying data with less visual clutter. The next plot shows (in the top row) two plots showing the effect of the `ellipse.conf` argument. The default is `ellipse.conf=0.3173`, which is an α-level corresponding to ±1 standard deviation from the bivariate mean. The upper right-hand plot shows `ellipse.conf=0.05`, which gives 95% confidence ellipses. The individual tokens are left visible to show their relationship with the ellipse extents. The bottom row shows how ellipses can be drawn as lines, fills, or both; how plotting ellipses interacts with the `group` argument; how the `style.by` argument affects the ellipse lines; and the utility of the `fill.opacity` argument when lots of filled objects overlap.

```{r, fig.cap="Ellipses"}
par(mfrow=c(2, 2))
with(indo, plotVowels(f1, f2, vowel, plot.tokens=TRUE, pch.tokens=vowel, alpha.tokens=0.2,
                      plot.means=TRUE, pch.means=vowel, cex.means=2, col.by=vowel,
                      ellipse.line=TRUE, pretty=TRUE))
with(indo, plotVowels(f1, f2, vowel, plot.tokens=TRUE, pch.tokens=vowel, alpha.tokens=0.2,
                      plot.means=TRUE, pch.means=vowel, cex.means=2, col.by=vowel,
                      ellipse.line=TRUE, ellipse.conf=0.05, pretty=TRUE))
with(indo, plotVowels(f1, f2, vowel, group=gender, plot.tokens=FALSE, plot.means=TRUE,
                      pch.means=vowel, cex.means=2, col.by=vowel, ellipse.fill=TRUE,
                      pretty=TRUE))
with(indo, plotVowels(f1, f2, vowel, group=subj, plot.tokens=FALSE, plot.means=TRUE,
                      pch.means=vowel, cex.means=2, col.by=vowel, style.by=subj,
                      ellipse.line=TRUE, ellipse.fill=TRUE, fill.opacity=0.1, pretty=TRUE))
```

In the lower-left plot above, we know from the function call that the two sets of ellipses correspond to talker gender, but it is not clear which ellipses “go together”. We can regain this information by passing arguments `ellipse.line=TRUE, style.by=gender`, but we can achieve the same thing by drawing connecting lines between the vowel means:

```{r, fig.cap="The “vowel means” polygon"}
with(indo, plotVowels(f1, f2, vowel, group=gender, plot.tokens=FALSE, plot.means=TRUE,
                      pch.means=vowel, cex.means=2, col.by=vowel, style.by=gender,
                      ellipse.fill=TRUE, poly.line=TRUE,
                      poly.order=c("i", "e", "a", "o", "u"), pretty=TRUE))
```

The vowel polygon lines (and also convex hulls, seen below) are drawn in black color if the `col.by` argument is `vowel` (because the polygonal boundary line is a property of the entire *vowel space*, not of any one vowel). If `col.by` is something else (like gender or talker) then the polygonal or hull line follows the color coding of the tokens and means. Just like ellipses (and hulls), vowel polygons may also have lines, fills, or both (controlled by the boolean `poly.line` and `poly.fill` arguments).

```{r, fig.height=3.75, fig.cap="Convex hulls with different values for the `color.by` argument"}
par(mfrow=c(1, 2))
with(indo, plotVowels(f1, f2, vowel, group=gender, pch.tokens=vowel, alpha.tokens=0.3,
                      plot.means=TRUE, pch.means=vowel, cex.means=2, col.by=vowel,
                      style.by=gender, hull.fill=TRUE, hull.line=TRUE, fill.opacity=0.1,
                      pretty=TRUE))
with(indo, plotVowels(f1, f2, vowel, group=gender, pch.tokens=vowel, alpha.tokens=0.3,
                      plot.means=TRUE, pch.means=vowel, cex.means=2, col.by=gender,
                      style.by=gender, hull.fill=TRUE, hull.line=TRUE, fill.opacity=0.1,
                      pretty=TRUE))
```

### Repulsive force heatmaps
One of the more unique aspects of `phonR` is its ability to calculate and plot the repulsive force of a vowel space. This is controlled by the argument `force.heatmap`, and its resolution by `force.res`. The colormap used to draw the heatmap defaults to grayscale if `pretty=FALSE` or to a warm palette if `pretty=TRUE`, but can be specified by passing a vector of color values as the `force.colmap` argument. See the `color.scale` function in the `plotrix` package for an easy way to create your own colormaps.


```{r, fig.cap="Repulsive force heatmaps of increasing resolution"}
coolcolors <- plotrix::color.scale(x=0:100, cs1=c(180, 360), cs2=c(25, 75), cs3=c(50, 100),
                                   alpha=1, color.spec='hcl')
indo$force <- with(indo, repulsiveForce(f2, f1, vowel))
par(mfrow=c(2, 2))
with(indo, plotVowels(f1, f2, vowel, plot.tokens=TRUE, pch.tokens=vowel, alpha.tokens=0.4,
                      force.heatmap=TRUE, force.colmap=coolcolors, force.res=10, 
                      col="white", pretty=TRUE))
with(indo, plotVowels(f1, f2, vowel, plot.tokens=TRUE, pch.tokens=vowel, alpha.tokens=0.4,
                      force.heatmap=TRUE, force.colmap=coolcolors, force.res=20, 
                      col="white", pretty=TRUE))
with(indo, plotVowels(f1, f2, vowel, plot.tokens=TRUE, pch.tokens=vowel, alpha.tokens=0.4,
                      force.heatmap=TRUE, force.colmap=coolcolors, force.res=40, 
                      col="white", pretty=TRUE))
with(indo, plotVowels(f1, f2, vowel, plot.tokens=TRUE, pch.tokens=vowel, alpha.tokens=0.4,
                      force.heatmap=TRUE, force.colmap=coolcolors, force.res=80, 
                      col="white", pretty=TRUE))
```

TODO: color tokens by force value in above plots; after fixing pineda method, increase resolution on below plots.

```{r, fig.cap="Comparison of `force.method` options. Left: deafult. Right: pineda."}
par(mfrow=c(1, 2))
with(indo, plotVowels(f1, f2, vowel, plot.tokens=TRUE, pch.tokens=vowel, alpha.tokens=0.4,
                      force.heatmap=TRUE, force.colmap=coolcolors, force.res=10, 
                      pretty=TRUE))
with(indo, plotVowels(f1, f2, vowel, plot.tokens=TRUE, pch.tokens=vowel, alpha.tokens=0.4,
                      force.heatmap=TRUE, force.colmap=coolcolors, force.res=10, 
                      force.method="pineda", pretty=TRUE))
```

### Legends
TODO

## Diphthongs
TODO
```{r}
# simulate some diphthongs
f1delta <- sample(c(-20:-10, 15:30), nrow(indo), replace=TRUE)
f2delta <- sample(c(-30:-20, 30:45), nrow(indo), replace=TRUE)
f1coefs <- matrix(sample(c(2:5), nrow(indo) * 4, replace=TRUE), nrow=nrow(indo))
f2coefs <- matrix(sample(c(3:6), nrow(indo) * 4, replace=TRUE), nrow=nrow(indo))
indo <- within(indo, {
    f1a <- f1 + f1delta * f1coefs[,1]
    f2a <- f2 + f2delta * f2coefs[,1]
    f1b <- f1a + f1delta * f1coefs[,2]
    f2b <- f2a + f2delta * f2coefs[,2]
    f1c <- f1b + f1delta * f1coefs[,3]
    f2c <- f2b + f2delta * f2coefs[,3]
    f1d <- f1c + f1delta * f1coefs[,4]
    f2d <- f2c + f2delta * f2coefs[,4]
    })

remapping <- c(i="ɪʏ̯", e="ɛœ̰ɚ", a="ɒɐ˞", o="ɤɞ̆", u="ɯʊ̥")
with(indo, plotVowels(cbind(f1, f1a, f1b, f1c, f1d), cbind(f2, f2a, f2b, f2c, f2d), 
                      vowel, plot.tokens=TRUE, pch.tokens=vowel, alpha.tokens=0.1,
                      plot.means=TRUE, pch.means=remapping[as.character(vowel)], 
                      cex.means=2, col.by=vowel, family="Charis SIL",
                      ellipse.line=TRUE, pretty=TRUE, diph.arrows=TRUE, 
                      diph.args.tokens=list(lwd=0.5)))
```

### Arrows
TODO

### Smoothing
TODO

# Vowel normalization with `phonR`
`phonR` implements eight different vowel formant frequency normalization function algorithms as separate functions, and additionally provides a convenience function `normalizeVowels` that wraps to the individual functions, specified by a `method` argument. The algorithms implemented are listed in Table 1. Most of the normalization functions accept a vector or matrix of $f_0$ or formant frequencies, and return a vector or matrix of the same dimensions.



| **Normalization method**               | **Function name**   | **Source**           | **Formula**                                           |
|:---------------------------------------|:--------------------|:---------------------|:------------------------------------------------------|
| Bark                                   | `normBark`          | [@traunmuller1990]   | $$ \frac {26.81 \times F_n}{1960+F_n} - 0.53 $$         |
| Equivalent Rectangular Bandwidth (ERB) | `normErb`           | [@glasbergMoore1990] | $$ 21.4 \times \log_{10} (1 + F_n \times 0.00437) $$    |
| Mel                                    | `normMel`           | [@mel]               | $$ 2595 \times \log_{10} (1 + \frac{F_n}{700}) $$       |
| Log                                    | `normLog`           | n/a                  | $$ \log_{10}(F_n) $$                                    |
| Lobanov (z‑score)                      | `normLobanov`       | [@lobanov1971]       | $$ \frac{F_n - \mu(F_n)}{\sigma(F_n)} $$                |
| Watt-Fabricius (s‑centroid)[^wf]       | `normWattFabricius` | [@wattFabricius2002] | $$ \frac{F_n}{centroid} $$                              |
| Nearey‑1 (logmean)                     | `normLogmean`       | [@nearey1977]        | $$ \log_{e} (F_n) - \mu(\log_{e}(F_n)) $$               |
| Nearey‑2 (nearey)                      | `normNearey`        | [@nearey1977]        | $$ \log_{e}(F_n) - \sum_{n=0}^{3} \mu(\log_{e}(F_n)) $$ |

\caption{Normalization methods available via `phonR` \texttt{normalizeVowels} function}

[^wf]: In `phonR`, the centroid is defined as the point $ \langle \frac{\min(\overline{F2}_{vowel})+\max(\overline{F2}_{vowel})}{2}, \frac{2 \times \min(\overline{F1}_{vowel})+\max(\overline{F1}_{vowel})}{3} \rangle $.  This varies slightly from the formula in [@wattFabricius2002], since the `phonR` implementation simply calculates which vowel has the highest mean F1 value and designates it as low corner of the triangle, rather than asking the user to expressly specify the *trap* or *start* vowel. Similarly, the `phonR` implementation simply calculates which vowel has the highest mean F2 value and uses that to calculate the upper left corner, rather than expressly looking for the mean of the “point-vowel” /i/.  The upper right corner is, as in the original method, derived from the other two corners.


<!--
## Styles
The `html_vignette` template includes a basic CSS theme. To override this theme you can specify your own CSS in the document metadata as follows:

    output:
      rmarkdown::html_vignette:
        css: mystyles.css

## More Examples
You can write math expressions, e.g. $Y = X\beta + \epsilon$, footnotes^[A footnote here.], and tables, e.g. using `knitr::kable()`.

```{r, echo=FALSE, results='asis'}
knitr::kable(head(mtcars, 10))
```

Also a quote using `>`:

> "He who gives up [code] safety for [code] speed deserves neither."
([via](https://twitter.com/hadleywickham/status/504368538874703872))
-->
